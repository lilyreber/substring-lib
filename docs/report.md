# Отчет о сравнении алгоритмов

Сбор данных проводится двумя способами, с использованием библиотеки Google Benchmark и
с использованием внутренней системы std::chrono. Тесты были проведены на платформах MacOs, Ubuntu 24.04.2 LTS и Windows 11.

### Тестовые условия
* Тесты для каждого способа проводятся независимо.
* Для каждого алгоритма проводится 3 вида тестов.
  * Наивный на поиск слова в простой строке.
  * На поиск случайной подстроки заданного размера в случайно сгенерированном.
  тексте заданного размера с латинским алфавитом.
  * Аналогичный тест на бинарном алфавите.
* Параметры тестов (размеры строк) задаются отдельно в `config.json`.

## Ожидания
m - размер паттерна, n - размер текста

1. **Knuth-Morris-Pratt (KMP) Algorithm**
   * Ответ на запрос в среднем: $\mathcal{O}(m)$
   * Ответ на запрос в худшем: $\mathcal{O}(n + m)$
   * Память $\mathcal{O}(m)$
2. **Boyer-Moore Algorithm**
   * Ответ на запрос: $\mathcal{O}(n + m)$
   * Ответ на запрос в худшем: $\mathcal{O}(n * m)$
   * Память $\mathcal{O}(m + s)$
3. **Rabin-Karp Algorithm**
    * Ответ на запрос: $\mathcal{O}(n + m)$
    * Ответ на запрос в худшем: $\mathcal{O}(n * m)$
    * Память: $\mathcal{O}(1)$
4. **Suffix Array Construction**
    * Ответ на запрос: $\mathcal{O}(m + log(n))$
    * Ответ на запрос в худшем: $\mathcal{O}(m + log(n))$
    * Память $\mathcal{O}(n)$
5. **Z-Algorithm**
    * Ответ на запрос: $\mathcal{O}(n + m)$
    * Ответ на запрос в худшем: $\mathcal{O}(n)$
    * Память $\mathcal{O}(n + m)$
6. **Not So Naive Algorithm**
    * Ответ на запрос: $\mathcal{O}(n + m)$
    * Ответ на запрос в худшем: $\mathcal{O}(n * m)$
    * Память: $\mathcal{O}(1)$

## Результаты
### MacOs ###
#### Среднее время работы относительно размера текста (тк размер паттерна не большой) через google benchmark
* `Rabin-Karp` и `Not So Naive` ~ 5n
* `Boyer-Moore` ~ 120n
* `KMP` ~ 250-300n
* `Z-Algorithm` ~ 500n
* `Suffix Array` ~ n * n

#### Среднее время работы, посчитанное через std::chrono, совпадает с тем, что было получено через google benchmark
* `Rabin-Karp` и `Not So Naive` ~ 0.005n microsec
* `Boyer-Moore` ~ 0.12n microsec
* `KMP` ~ 0.25n microsec
* `Z-Algorithm` ~ 0.5n microsec
* `Suffix Array` ~ 2-9n microsec

#### Средняя затраченная память
* `Rabin-Karp`: ~ 0 KB
* `Not So Naive`: ~ 0 KB
* `Boyer-Moore`: ~ 4n B
* `KMP`: ~ 8n B
* `Z-Algorithm`: ~ 16n B
* `Suffix Array`: ~ 27n B

#### Общие сведения
* Алгоритмы `Rabin-Karp` и `Not-so-naive` показывают схожую производительность на всех тестах, как на малых, так и на больших данных.
* На бинарных строках `KMP` и `Z-Algorithm` работают хуже, чем на строках с латинскими символами.
* Для `Boyer-Moore`, `Rabin-Karp` и `Not-so-naive` разница в производительности между бинарными и латинскими строками незначительна.
* `KMP` и `Boyer-Moore` используют умеренное количество памяти, особенно на больших данных.
* `Rabin-Karp` и `Not-so-naive` используют минимальную память, что делает их подходящими для задач с ограниченными ресурсами.
* `Z-Algorithm` и `Suffix-Array` требуют значительной памяти, особенно на больших данных, что может быть ограничивающим фактором для их использования.
* Затраты памяти для всех алгоритмов соответствуют их теоретическим ожиданиям.
* `Rabin-Karp` и `Not So Naive` являются наиболее экономичными по памяти.
* `Boyer-Moore`, `KMP`, `Z-Algorithm` и `Suffix Array` требуют больше памяти, что может быть ограничивающим фактором для их использования на больших данных.

### Ubuntu 24.04.2 LTS ###
#### Среднее время работы относительно размера текста (тк размер паттерна не большой) через google benchmark
* `Rabin-Karp` ~ 18n ns
* `Not So Naive` ~ 18n ns
* `Boyer-Moore` ~ 31n ns
* `KMP` ~ 54n ns
* `Z-Algorithm` ~ 181n ns
* `Suffix Array` ~ n * n ns

#### Среднее время работы, посчитанное через std::chrono, совпадает с тем, что было получено через google benchmark
* `Rabin-Karp` ~ 18n ns
* `Not So Naive` ~ 18n ns
* `Boyer-Moore` ~ 31n ns
* `KMP` ~ 54n ns
* `Z-Algorithm` ~ 181n ns
* `Suffix Array` ~ n * n ns

#### Средняя затраченная память
* `Rabin-Karp` ~ 0 KB
* `Not So Naive` ~ 0 KB
* `Boyer-Moore` ~ (2048 + n) B
* `KMP` ~ 8n B
* `Z-Algorithm` ~ 9n B
* `Suffix Array` ~  24n B

#### Общие сведения
* Rabin-Karp и Not-so-naive остаются самыми быстрыми алгоритмами с константами 18.
* Алгоритмы `Rabin-Karp` и `Not So Naive` показывают практически идентичные результаты на всех тестах
* На очень маленьких данных, до 100 символов текста, `KMP` показывает себя лучше чем `Boyer-Moore` и `Z-Algorithm`, после чего, по увеличению текста, наилучшим становиться `Boyer-Moore`, примерно в два раза дольше работает `KMP`, а еще в два раза хуже - `Z-Algorithm`.
* `Suffix Array Construction` - работает в 10-20 раз хуже остальных алгоритмов, на всех тестах кроме текста размера 10.
* С бинарными строками хуже справляются `KMP` и `Z-Algorithm`. Для `Boyer-Moore`, `Rabin-Karp` и `Not So Naive`
  разница не значительная, а `Suffix Array` заметно ускоряется.

### Windows 11 ###
#### Среднее время работы относительно размера текста (тк размер паттерна не большой) через google benchmark
* `Rabin-Karp` ~ 40n ns
* `Not So Naive` ~ 40n ns
* `Boyer-Moore` ~ 106n ns
* `KMP` ~ 300n ns
* `Z-Algorithm` ~ 387n ns
* `Suffix Array` ~ n * n ns

#### Среднее время работы, посчитанное через std::chrono, совпадает с тем, что было получено через google benchmark
* `Rabin-Karp` ~ 40n ns
* `Not So Naive` ~ 40n ns
* `Boyer-Moore` ~ 106n ns
* `KMP` ~ 300n ns
* `Z-Algorithm` ~ 387n ns
* `Suffix Array` ~ n * n ns

#### Средняя затраченная память
* `Rabin-Karp` ~ 0 KB
* `Not So Naive` ~ 0 KB
* `Boyer-Moore` ~ 3n B
* `KMP` ~ 12n B
* `Z-Algorithm` ~ 9n B
* `Suffix Array` ~  27n B

#### Общие сведения
* `Rabin-Karp` и `Not So Naive` демонстрируют схожую производительность на всех типах данных, как на малых, так и на больших.
* `KMP` и `Z-Algorithm` работают хуже на бинарных строках по сравнению с латинскими из-за особенностей алгоритмов.
* `Boyer-Moore`, `Rabin-Karp` и `Not So Naive` показывают незначительную разницу в производительности между бинарными и латинскими строками.
* `KMP` и `Boyer-Moore` используют среднее количество памяти, что может быть приемлемо для большинства задач.
* `Rabin-Karp` и `Not So Naive` наиболее экономичны по памяти.
* `Z-Algorithm` и `Suffix Array` требуют значительной памяти, что может быть ограничивающим фактором для их использования на больших данных.

## Вывод
### Время
* Наиболее оптимальными по времени на всех платформах являются `Rabin-Karp` и `Not So Naive`. Работают за линейное время $\mathcal{O}(n + m)$.
* Время выполнения `Boyer-Moore` и `KMP` хуже, чем у `Rabin-Karp` и `Not So Naive`, особенно на Windows.
* Хуже всего себя показали `Z-Algorithm` и `Suffix Array`. На Windows производительность особенно низкая, что может быть связанно с накладными расходами.
* `Suffix Array` имеет квадратичную сложность, что делает его непригодным для больших данных.

### Память
* `Rabin-Karp` и `Not So Naive` практически не используют дополнительную память, что делает их очень эффективными с точки зрения использования ресурсов. Затраты памяти $\mathcal{O}(1)$.
* `Boyer-Moore` требует больше памяти, по сравнению с пердыдущими алгоритмами, при этом затраты по памяти на Windows и MacOS чуть меньше.
* `KMP` потребляет больше памяти на всех платформах из-за необходимости хранения префикс функции.
* `Z-Algorithm` и `Suffix Array` потребляют больше всего памяти, что делает их наименее эффективными.

### Общее
* Наиболее эффективными по памяти и по времени являются `Rabin-Karp` и `Not So Naive`.
* Чуть хуже себя показывает `Boyer-Moore`, на на Windows его производительность хуже, чем на остальных ОС.
* `KMP`, `Z-Algorithm` и `Suffix Array` проигрывают по производительности и использованию памяти, но могут быть полезны в специфических случаях.

## Примечание
* Протестировать отдельно время построения и запроса на данных момент не имеет смысла, поскольку наша библиотека не предоставляет такой сценарий использования на данный момент. При добавлении функциональности, надо расширять тестовую базу.
* Алгоритм `suffix_array` пришлось тестировать отдельно, без учета самых крупных на размер текста тестов, поскольку алгоритм затрачивает слишком много времени и памяти для него и является непригодным.

