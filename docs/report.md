# Отчет о сравнении алгоритмов

Сбор данных проводится двумя способами, с использованием библиотеки Google Benchmark и
с использованием внутренней системы std::chrono. Тесты были проведены на платформах MacOs, Ubuntu 24.04.2 LTS и Windows 11. 

### Тестовые условия
* Тесты для каждого способа проводятся независимо
* Для каждого алгоритма проводится 3 вида тестов
  * Наивный на поиск слова в простой строке
  * На поиск случайной подстроки заданного размера в случайно сгенерированном
  тексте заданного размера с латинским алфавитом
  * Аналогичный тест на бинарном алфавите
* Параметры тестов (размеры строк) задаются отдельно в `config.json`

## Ожидания
m - размер паттерна, n - размер текста

1. **Knuth-Morris-Pratt (KMP) Algorithm**
   * Ответ на запрос в среднем: $\mathcal{O}(m)$
   * Ответ на запрос в худшем: $\mathcal{O}(n + m)$
   * Память $\mathcal{O}(m)$
2. **Boyer-Moore Algorithm**
   * Ответ на запрос: $\mathcal{O}(n + m)$
   * Ответ на запрос в худшем: $\mathcal{O}(n * m)$
   * Память $\mathcal{O}(m + s)$
3. **Rabin-Karp Algorithm**
    * Ответ на запрос: $\mathcal{O}(n + m)$
    * Ответ на запрос в худшем: $\mathcal{O}(n * m)$
    * Память: $\mathcal{O}(1)$
4. **Suffix Array Construction**
    * Ответ на запрос: $\mathcal{O}(m + log(n))$
    * Ответ на запрос в худшем: $\mathcal{O}(m + log(n))$
    * Память $\mathcal{O}(n)$
5. **Z-Algorithm**
    * Ответ на запрос: $\mathcal{O}(n + m)$
    * Ответ на запрос в худшем: $\mathcal{O}(n)$
    * Память $\mathcal{O}(n + m)$
6. **Not So Naive Algorithm**
    * Ответ на запрос: $\mathcal{O}(n + m)$
    * Ответ на запрос в худшем: $\mathcal{O}(n * m)$
    * Память: $\mathcal{O}(1)$

## Результаты
### MacOs ###
#### Среднее время работы относительно размера текста (тк размер паттерна не большой) через google benchmark
* `Rabin-Karp` и `Not So Naive` ~ 5n
* `Boyer-Moore` ~ 120n
* `KMP` ~ 250-300n
* `Z-Algorithm` ~ 500n
* `Suffix Array` ~ n * n

#### Среднее время работы, посчитанное через std::chrono, совпадает с тем, что было получено через google benchmark
* `Rabin-Karp` и `Not So Naive` ~ 0.005n microsec
* `Boyer-Moore` ~ 0.12n microsec
* `KMP` ~ 0.25n microsec
* `Z-Algorithm` ~ 0.5n microsec
* `Suffix Array` ~ 2-9n microsec

#### Общие сведения
* Rabin-Karp и Not-so-naive остаются самыми быстрыми алгоритмами с константами 18.
* Алгоритмы `Rabin-Karp` и `Not So Naive` показывают практически идентичные результаты на всех тестах
* На очень маленьких данных, до 100 символов текста, `KMP` показывает себя лучше чем `Boyer-Moore` и `Z-Algorithm`,
  после чего, по увеличению текста, наилучшим становиться `Boyer-Moore`, примерно в два раза дольше работает `KMP`, а еще
  в два раза хуже - `Z-Algorithm`.
* `Suffix Array Construction` - работает в 10-20 раз хуже остальных алгоритмов, на всех тестах кроме текста размера 10.
* С бинарными строками хуже справляются `KMP` и `Z-Algorithm`. Для `Boyer-Moore`, `Rabin-Karp` и `Not So Naive`
  разница не значительная, а `Suffix Array` заметно ускоряется.

### Ubuntu 24.04.2 LTS ###
#### Среднее время работы относительно размера текста (тк размер паттерна не большой) через google benchmark
* `Rabin-Karp` ~ 18n ns
* `Not So Naive` ~ 18n ns
* `Boyer-Moore` ~ 31n ns
* `KMP` ~ 54n ns
* `Z-Algorithm` ~ 181n ns
* `Suffix Array` ~ n * n ns

#### Среднее время работы, посчитанное через std::chrono, совпадает с тем, что было получено через google benchmark
* `Rabin-Karp` ~ 18n ns
* `Not So Naive` ~ 18n ns
* `Boyer-Moore` ~ 31n ns
* `KMP` ~ 54n ns
* `Z-Algorithm` ~ 181n ns
* `Suffix Array` ~ n * n ns

#### Средняя затраченная память
* `Rabin-Karp` ~ 0 KB
* `Not So Naive` ~ 0 KB
* `Boyer-Moore` ~ (2048 + n) B
* `KMP` ~ 8n B
* `Z-Algorithm` ~ 9n B
* `Suffix Array` ~  24n B

#### Общие сведения
* Алгоритмы `Rabin-Karp` и `Not-so-naive` показывают схожую производительность на всех тестах, как на малых, так и на больших данных.
* На бинарных строках `KMP` и `Z-Algorithm` работают хуже, чем на строках с латинскими символами.
* Для `Boyer-Moore`, `Rabin-Karp` и `Not-so-naive` разница в производительности между бинарными и латинскими строками незначительна.
* `KMP` и `Boyer-Moore` используют умеренное количество памяти, особенно на больших данных.
* `Rabin-Karp` и `Not-so-naive` используют минимальную память, что делает их подходящими для задач с ограниченными ресурсами.
* `Z-Algorithm` и `Suffix-Array` требуют значительной памяти, особенно на больших данных, что может быть ограничивающим фактором для их использования.
* Затраты памяти для всех алгоритмов соответствуют их теоретическим ожиданиям.
* `Rabin-Karp` и `Not So Naive` являются наиболее экономичными по памяти.
* `Boyer-Moore`, `KMP`, `Z-Algorithm` и `Suffix Array` требуют больше памяти, что может быть ограничивающим фактором для их использования на больших данных.

## Вывод
Наиболее оптимальными на данный момент по времени являются `Rabin-Karp` и `Not So Naive` и по сути не имеют различий. Работают
порядка $\mathcal{O}(n + m)$.

Наиболее оптимальными по памяти на данный момент являются `Rabin-Karp` и `Not So Naive`. Затраты памяти $\mathcal{O}(1)$.

В то время как `Boyer-Moore`, `KMP` и `Z-Algorithm` проигрывают по всем параметр они все еще остаются приемлемыми
для решения конкретных задач

`Suffix Array` - тратит на порядок больше времени, единственное его преимущество это последующее расширение библиотеки и
добавление функциональности, при котором он окажется в выигрыше

### Примечание
* Протестировать отдельно время построения и запроса на данных момент не имеет смысла,
поскольку наша библиотека не предоставляет такой сценарий использования на данный момент. При добавлении функционала,
надо расширять тестовую базу
* Алгоритм `suffix_array` пришлось тестировать отдельно, без учета самых крупных на размер текста тестов,
поскольку алгоритм затрачивает слишком много времени и памяти для него и является непригодным

### Windows 11 ###
#### Среднее время работы относительно размера текста (тк размер паттерна не большой) через google benchmark
* `Rabin-Karp` ~ 40n ns
* `Not So Naive` ~ 40n ns
* `Boyer-Moore` ~ 106n ns
* `KMP` ~ 300n ns
* `Z-Algorithm` ~ 387n ns
* `Suffix Array` ~ n * n ns

#### Среднее время работы, посчитанное через std::chrono, совпадает с тем, что было получено через google benchmark
* `Rabin-Karp` ~ 40n ns
* `Not So Naive` ~ 40n ns
* `Boyer-Moore` ~ 106n ns
* `KMP` ~ 300n ns
* `Z-Algorithm` ~ 387n ns
* `Suffix Array` ~ n * n ns

#### Средняя затраченная память
* `Rabin-Karp` ~ 0 KB
* `Not So Naive` ~ 0 KB
* `Boyer-Moore` ~ 3n B
* `KMP` ~ 12n B
* `Z-Algorithm` ~ 9n B
* `Suffix Array` ~  27n B

#### Общие сведения
* `Rabin-Karp` и `Not So Naive` демонстрируют схожую производительность на всех типах данных, как на малых, так и на больших.
* `KMP` и `Z-Algorithm` работают хуже на бинарных строках по сравнению с латинскими из-за особенностей алгоритмов.
* `Boyer-Moore`, `Rabin-Karp` и `Not So Naive` показывают незначительную разницу в производительности между бинарными и латинскими строками.
* `KMP` и `Boyer-Moore` используют среднее количество памяти, что может быть приемлемо для большинства задач.
* `Rabin-Karp` и `Not So Naive` наиболее экономичны по памяти.
* `Z-Algorithm` и `Suffix Array` требуют значительной памяти, что может быть ограничивающим фактором для их использования на больших данных.

## Вывод
Наиболее оптимальными по времени являются `Rabin-Karp` и `Not So Naive` и по сути не имеют различий. Работают
порядка $\mathcal{O}(n + m)$.

Наиболее оптимальными по памяти на данный момент являются `Rabin-Karp` и `Not So Naive`. Затраты памяти $\mathcal{O}(1)$ и на данной операционной системе около 0 KB.

`KMP` и `Z-Algorithm` значительно медленнее из-за сложной предобработки и дополнительных операций.

`Suffix Array` имеет квадратичную сложность, что делает его непригодным для больших данных.

### Примечание
* Алгоритм `suffix_array` пришлось тестировать отдельно, без учета самых крупных на размер текста тестов,
поскольку алгоритм затрачивает слишком много времени и памяти для него и является непригодным.

