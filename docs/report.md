# Отчет о сравнении алгоритмов

Сбор данных проводиться двумя способами, с использованием библиотеки Google Benchmark и 
с использованием внутренней системы std::crono. Тесты были проведены на платформе MacOs

### Тестовые условия
* Тесты для каждого способа проводятся независимо
* Для каждого алгоритма проводиться 3 вида тестов
  * Наивный на поиск слова в простой строке
  * На поиск случайной подстроки заданного размера в случайно сгенерированном 
  тексте заданного размера с латинским алфавитом
  * Аналогичный тест на бинарном алфавите
* Параметры тестов (размеры строк) задаются отдельно в `config.json`

## Ожидания
m - размер паттерна, n - размер текста

1. **Knuth-Morris-Pratt (KMP) Algorithm**
   * Ответ на запрос в среднем: $\mathcal{O}(m)$
   * Ответ на запрос в худшем: $\mathcal{O}(n + m)$
2. **Boyer-Moore Algorithm**
   * Ответ на запрос: $\mathcal{O}(n + m)$
   * Ответ на запрос в худшем: $\mathcal{O}(n * m)$
3. **Rabin-Karp Algorithm**
    * Ответ на запрос: $\mathcal{O}(n + m)$
    * Ответ на запрос в худшем: $\mathcal{O}(n * m)$
4. **Suffix Array Construction**
    * Ответ на запрос: $\mathcal{O}(m + log(n))$
    * Ответ на запрос в худшем: $\mathcal{O}(m + log(n))$
5. **Z-Algorithm**
    * Ответ на запрос: $\mathcal{O}(n + m)$
    * Ответ на запрос в худшем: $\mathcal{O}(n)$
6. **Not So Naive Algorithm**
    * Ответ на запрос: $\mathcal{O}(n + m)$
    * Ответ на запрос в худшем: $\mathcal{O}(n * m)$

## Результаты
Среднее время работы относительно размера текста (тк размер паттерна не большой) через Goggle benchmark
* `Rabin-Karp` и `Not So Naive` ~ 5n
* `Boyer-Moore` ~ 120n
* `KMP` ~ 250-300n
* `Z-Algorithm` ~ 500n
* `Suffix Array` ~ n * n


Среднее время работы, посчитанное через std::crono совпадает с тем, что было получено через google benchmark
* `Rabin-Karp` и `Not So Naive` ~ 0.05n microsec
* `Boyer-Moore` ~ 0.12n microsec
* `KMP` ~ 0.25n microsec
* `Z-Algorithm` ~ 0.5n microsec
* `Suffix Array` ~ 2-9n microsec

* Алгоритмы `Rabin-Karp` и `Not So Naive` показывают практически идентичные результаты на всех тестах
* На очень маленьких данных, до 100 символов текста, `KMP` показывает себя лучше чем `Boyer-Moore` и `Z-Algorithm`,
  после чего, по увеличению текста, наилучшим становиться `Boyer-Moore`, примерно в два раза дольше работает `KMP`, а еще
  в два раза хуже - `Z-Algorithm`.
* `Suffix Array Construction` - работает в 10-20 раз хуже остальных алгоритмов, на всех тестах кроме текста размера 10.
* С бинарными строками хуже справляются `KMP` и `Z-Algorithm`. Для `Boyer-Moore`, `Rabin-Karp` и `Not So Naive`
  разница не значительная, а `Suffix Array` заметно ускоряется

## Вывод
Наиболее оптимальными на данный момент являются `Rabin-Karp` и `Not So Naive` и по сути не имеют различий. Работают 
порядка $\mathcal{O}(n + m)$. 

В то время как `Boyer-Moore`, `KMP` и `Z-Algorithm` проигрывают по всем параметр они все еще остаются приемлимыми 
для решения конкретных задач

`Suffix Array` - тратит на порядок больше времени, единственное его преимущество это последующее расширение библиотеки и 
добавление функционала, при котором он окажется в выигрыше

### Примечание
* Протестировать отдельно время построения и запроса на данных момент не имеет смысла, 
поскольку наша библиотека не предоставляет такой сценарий использования на данный момент. При добавлении функционала, 
надо расширять тестовую базу
* Алгоритм ```suffix_array``` пришлось тестировать отдельно, без учета самых крупных на размер текста тестов, 
поскольку алгоритм не затрачивает слишком много времени и памяти для него и является непригодным

